<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LRU</title>
    <link rel="stylesheet" href="assets/css/style.css">
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Raleway" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="HandheldFriendly" content="true">
</head>

<body>
    <h1>Least recently used (LRU)</h1>
    <p>Discards the least recently used items first. This algorithm requires keeping track of what was used when, which is expensive if one wants to make sure the algorithm always discards the least recently used item. General implementations of this technique
        require keeping "age bits" for cache-lines and track the "Least Recently Used" cache-line based on age-bits. In such an implementation, every time a cache-line is used, the age of all other cache-lines changes. LRU is actually a family of caching
        algorithms with members including 2Q by Theodore Johnson and Dennis Shasha, and LRU/K by Pat O'Neil, Betty O'Neil and Gerhard Weikum.</p>
    <p>The access sequence for the below example is A B C D E D F.</p>
    <img src="https://upload.wikimedia.org/wikipedia/commons/8/88/Lruexample.png" />
    <p>In the above example once A B C D gets installed in the blocks with sequence numbers (Increment 1 for each new Access) and when E is accessed, it is a miss and it needs to be installed in one of the blocks. According to the LRU Algorithm, since A
        has the lowest Rank(A(0)), E will replace A.</p>
    <p>Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.</p>

    <h2>Implement the LRUCache class:</h2>

    <p><code>LRUCache(int capacity)</code> Initialize the LRU cache with positive size capacity.</p>
    <p><code>int get(int key)</code> Return the value of the key if the key exists, otherwise return -1.</p>
    <p><code>void put(int key, int value)</code> Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.</p>
    <h3>Follow up:</h3>
    <p>Could you do get and put in O(1) time complexity?</p>
    <div w3-include-html="lru_code.html"></div>
</body>
<script src="assets/js/script.js"></script>
<script>
    includeHTML();
</script>

</html>